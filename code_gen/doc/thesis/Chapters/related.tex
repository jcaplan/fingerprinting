% Chapter Template

\chapter{Related Work} % Main chapter title

\label{c:related} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------


Many recent projects explore code generation for real-time multicore systems. Several groups have demonstrated integrated frameworks that allows specification of both a hardware and software model and generates both hardware and software code \cite{goossens2013compsoc,gauthier2001automatic}. Strategies for code generation in real-time systems also exist that use platform specific features to address thread replication and fault tolerance \cite{huang2012framework}.

Mapping strategies and automated design space exploration for multicore systems are explored in \cite{bolchini2013reliability}, and \cite{kang2014static}. Recent work has also examined porting of multi-rate synchronous languages to multicore systems \cite{puffitsch2013mapping}. I am also involved in a recently accepted conference paper on this subject that proposes a different analysis technique.

The analysis in \cite{kang2014static} was tested in real many-core systems in \cite{sigrist2015mixed}. It was found that the models are inaccurate and that many of the model assumptions are extremely optimistic (up to 97\% of systems that passed analysis failed on real hardware). Work moving forward will depend on closing the gap between the models and systems and working non-ideal considerations in an integrated framework. An effective profiling tool will be critical to reducing time-consuming iterations and reducing at least one key source of error in the mapping and scheduling analysis.

Implicite path enumeration technique (IPET) is a standard method of analysis to determine the worst case execution time of a program from its control flow graph \cite{li1995performance}. The IPET framework developed for this thesis is inspired by the open source tool Heptane~\cite{heptane}. The static analysis on loops is based on the standard \emph{Modern Compiler Implementation}~\cite{andrew2002modern}.


Fingerprinting was introduced in \cite{Smolens:04} as a method of detecting errors. On-demand redundancy \cite{Meyer:CASES11,fu2013demand} and dynamic core coupling \cite{lafrieda2007utilizing} discuss potential performance gains arising from non-lockstep based architectures for mixed-criticality applications.  The L4.fiasco microkernel also uses fingerprinting to monitor redundant threads \cite{dobel2012operating} and propose a similar architecture with a \emph{trusted computing base} \cite{dobel2012watches}.

Moma \cite{ferreira2014adaptive} is a proposed architecture that uses replication in the pipeline to detect errors at the microarchitectural level. The compiler forces live state out of registers at the end of all basic blocks to reduce opportunities for errors to manifest in the registers themselves and a fault tolerant matrix multiplication accelerator accompanies a RISC core to boost performance. Nostradamus is a low cost single core hardened architecture that employs various techniques to protect the pipeline \cite{nathan2014nostradamus}. Software implemented fault tolerance applies compiler transformations to insert replication and self-testing at the assembly level \cite{reis2005swift}.