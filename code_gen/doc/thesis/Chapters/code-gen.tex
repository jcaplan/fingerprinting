% Chapter Template

\chapter{Code Generation} % Main chapter title
\label{c:code-gen}

	The profiling and mapping stages in Figure~\ref{f:tool-arch} have been covered in Chapters~\ref{c:prof} and \ref{c:sched}. 
	The behaviour of the target platform was covered in Chapter~\ref{c:soft-impl}. 
	This chapter focuses on the code generation (CG) stage which generates complete software solution. The basic flow is shown in Algorithm~\ref{l:cg-flow}. Each step in the flow will be briefly discussed.
	
	
\begin{algorithm}
\SetKwFunction{GenerateCode}{GenerateCode}

\Fn{\GenerateCode{Configuration}}{
	\If{No BSP found}{
		Generate BSPs\;
	}
	\If{Profiling required}{
		Profile binary code\;
	}
	\If{Mapping required}{
		Find mapping\;
	}
	Copy source code to app directories\;
	Parse source code\;
	Generate scripts\;
	Calculate stack bins\;
	Generate monitor main\;
	Generate processing cores main\;
}
\caption{Basic code generation flow.}
\label{l:cg-flow}
\end{algorithm}

\section{BSP Generation}
	Altera provides a command line interface (Nios SBT) for the generation and customization of Nios II BSPs based on hardware platforms specified using Quartus QSYS. 
	CG generates and runs bash scripts that use the Nios SBT and provides a paper-trail for the user so that they can manually update and re-run the scripts in case some modification is required.
	Some BSP modifications are not easily supported by the Nios SBT and must be manually configured by the shell script including: Updating the version of uC/OS-II RTOS to be compatible with the Imperas OS debugging tools, repacing customized files in the generated bare-metal drivers (HAL), modifying certain errors in generated files due to known bugs in the Nios SBT (especially the linker script and ``system.h'' file , and adding drivers for all the custom hardware and software libraries. Appendix~\ref{A:ConfigScripts} contains example scripts.

\section{Code Profiling}

	A sample project is required to profile the code for each task computation. 
	A new application project is configured for one of the generated BSPs using an example main program generated by Simulink using each function. 
	The tool is configured to recognize the default naming patterns used by Simulink. 
	Future work could provide full customization of naming patterns to match the Simulink options. 
	The profiling proceeds according to Chapter~\ref{c:prof} once the project has been compiled and the gcc tool \texttt{nios2-elf-objdump} has been used to generate assembly code and extract annotations.

\section{Mapping and Scheduling}
	The mapping and scheduling tool is automatically configured to test the default platform and task set using information from the configuration file and optionally the profiling results.
	The program exits if no mapping solution is found.

\section{Parsing Source Code}

	The Simulink generated source code must also be parsed to determine if the functions have default parameters and/or persistent state. 
	These data structures require special handling in the setup of the data structures because there is a containing \emph{model struct} for which the pointers to these variables must be set. 
	Listing~\ref{l:pointer-setup} shows the generated code for setting up the struct.
	
\includecode{pointer-setup.c}{l:pointer-setup}{Setting up data for radar tracking function}{C}
	

	Simulink generates the \texttt{RT\_MODEL\_*} data struct which contains the pointers to parameters and state as well as a struct for inputs (\texttt{EXT\_U\_*}) and outputs (\texttt{EXT\_Y\_*}). 
	The \texttt{*\_initialize} function called on line 13 is generated by Simulink. The update pointer function is called twice - once before initializing the model struct and once after. 
	The pointer to the state variable initially points to the physical address because the monitor will modify the variable in the \texttt{initialize} function. 
	Afterwards, the pointer is set to the virtual address that the processing core will use.

\section{Generating Application}

The application Makefile can be generated using Nios SBT after all the source code is generated. Appendix~\ref{A:ConfigScripts} contains a sample script.

\section{Stack Bin Calculation}

	The stack and data for critical task are placed in separate memory regions from the rest of the application. 
	The linker script is not modified until the final mapping is known in order to minimize the amount of memory that must be partitioned.
	Appendix~\ref{A:ConfigScripts} contains a sample script.

\section{Generating Main Files}

	Algorithm~\ref{l:cg-monitor} shows the steps for generating the main monitor file. 
	The steps for generating code for the processing core are the same however the implementation differs for several. 
	The code generation follows a simple template based approach where specific values must be substituted into generic templates based on the application configuration.
	Appendix~\ref{A:moncode} contains a sample of generated monitor code and processing core.


\begin{algorithm}
\SetKwFunction{GenerateMonitor}{GenerateMonitor}

\Fn{\GenerateMonitor{}}{
	Generate list of files to include\;
	Generate global variable declarations\;
	Generate task stack declarations\;
	Generate initializion code for the execution time monitor\;
	Generate interrupt handlers\;
	Generate task wrappers\;
	Generate initializion code for memory manager\;
	Generate MPU initialization code\;
	Generate main function\;
}
\caption{Basic code generation flow.}
\label{l:cg-monitor}
\end{algorithm}


\section{Example}

	Appendix~\ref{A:ConfigFile} contains a configuration file for a code generation project. 
	Two functions have been generated using Simulink that execute some for loop. Table~\ref{t:config} summarizes the parameters.
	
	
	

\begin{table}[h]
\caption{Example application}
\centering

	\begin{tabular}{@{}llllllll@{}}
	\toprule
	Function & Per. & Crit. & Prio. & Mapping & Max Stack & C(LO) & C(HI) 	 \\
	for\_loop\_100000\_0 & 30 & HI & 2 & cpu0,cpu1 & 80 & 1600004 & 2400006 \\
	for\_loop\_50000\_50000 & 30 & LO & 1 & cpu0 & 80 & 1600035 & - \\
	\end{tabular}

\label{t:config}
\end{table}
	

	The generated code is executed on the OVP virtual platform using Imperas debugging tools. The Imperas debugger analyzes the RTOS and generates a waveform representing the activity of the various tasks. 
	An excerpt of the simulation is shown in Figure~\ref{f:sim1}.
	The DMA task on the monitor executes once at 542 ms and takes almost no time since the delay for DMA transfer is not modelled.
	The two copies of the HI task execute in parallel. The LO task interrupts the HI task on cpu0 however the response time remains under 30ms.
\addfigure{0.44}{sim1.png}{Simulation of sample program}{f:sim1}
	
	We can observe a mode change by setting C(LO) to 12 ms for the LO task because it has been configured to run between 8-12 ms. 
	Figure~\ref{f:sim2} shows that once the LO task executes for 12 ms it is dropped while the HI task continues to run.
	 
\addfigure{0.42}{sim2.png}{LO task is dropped after $C > C(LO)$}{f:sim2}
		
	Finally, in the case of an error, the task must be re-executed. 
	A transient fault is simulated by pausing the simulation and changing the value in a general purpose register. 
	The DMA task runs again as it re-sends the stack and data to the scratchpads.
	The LO task does not execute after the fault as a mode change occurs.
	
		 
\addfigure{0.45}{sim3.png}{HI task is re-executed after fault is detected}{f:sim2}
		
